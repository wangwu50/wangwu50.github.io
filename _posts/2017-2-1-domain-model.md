---
layout: post
title: 领域模型
date: 2017-1-6
categories: blog
tags: [技术,模型]
description: 对领域模型的思考

---

项目中大部分时间在使用spring，前段时间有位同事写的一段代码引起了我的思考。代码大致思路是这样的：

```java

public class DomainModel {
    private long id;
    private long id2;
    private long id3;
    public DomainModel(long longId) {
        id = longId;
        id2=id+1;
        id3=id2+1;
    }
    public void run(){
        System.out.println(id3);
    }
    public static void main(String[] args) {
        DomainModel model = new DomainModel(11);
        model.run();
    }
}

```

这段代码和我们平时写的类还是有一些区别的，spring里面默认所有类都是单例的，这就导致我们写所有代码都必须是无状态的。而上面这段代码里面有3个状态，根据构造器传入的值不同，状态也不一样。这样的类是无法被spring管理的。

在实际生产中，我们一般把后台代码分成3层，分别是dao、service、control。我们的主要业务逻辑是在service层中的，dao层由orm框架接管，control层只做一些简单的参数校验和json解析。为了和dao层对应，一般还会有一个bean。
这个bean有对应数据库的所有字段，然后有简单的getXX、setXX方法。这些bean是实际存储状态的类。service层的逻辑实际上都是对bean的状态的改变，因此service层的类可以说是bean的管理类。
在领域模型中，这种javabean中仅有简单的getXX、setXX方法，主要逻辑写在管理类中的模型，叫做贫血模型，它的本质是把行为和状态分离到不同的对象中去，只有状态的叫做“贫血对象”，只有行为的对应Logic/Service/Manager层。
在学习面向对象的时候，书上会说，一个类拥有状态和行为，状态用域表示，行为用方法表示。一个人可以吃饭、唱歌，这是这个人的本身的行为，不应该由人的管理层来实现。
充血模型，就是把这些行为还原回bean层，每个类管理自身的行为，类与类之间互相通信，协作完成任务。从本质来说，这种模式更加面向对象。

spring成为了现在javaweb开发的实际标准，但也因此改变了日常开发的习惯。开发过程中，由于spring的单例特性，贫血模型是我们几乎唯一的选择。总结一下，贫血模型有以下几点好处：

- 大部分开发者都能简单理解
- 能够与dao层很好的协作。
- 事务的边界很容易划分

但贫血模型的问题也有很多，但逻辑的增加时，这些缺点会凸显，贫血模式说到底还是有很多面向过程的影子，在《企业应用架构模式》中，这种模式叫做事务脚本。缺点有：

1. 当同一段逻辑需要复用时，很可能有代码重复的隐患。即使将变成公共方法，也会加大编写和理解难度。
2. Service层过于厚重，方法过多没有关联，散落在各处不好管理。

当问题比较复杂时候，引入充血模型是一个比较好的选择，可以把充血模型中的每个bean看作一个个服务，整个流程就是各个类在接受消息，处理消息。不再是一个过程控制用户某个行为，而是由每一个对象都承担一部分逻辑。
这种模型的使用充分利用了面向对象的好处，但也有一些缺点：
1. 将逻辑从复杂的业务中分离并恰到好处的放到某个对象中很困难，只有一些资深的程序员能够胜任这些工作。
2. 考虑到类的初始化开销，将行为抽象出成为类，这些类都是无状态的，可以复用，spring中的单例类就是这种情况。而使用充血模型，每次请求都需要新创建类，性能相对比较低下。
3. 最重要的一点，有状态的类和spring中的单例类不好兼容（即使将其单独设置为多例的也不行，因为引用它的类是单例的，只会初始化一次）。

在日常开发中，我们大部分都是在用贫血模型。包括现成的很多代码生成器，很多持久化框架、大部分json解析器，都是默认使用贫血对象。但看起来充血对象又更贴近OOP。我当时也被这个问题困扰了很久，其实纠结于使用那种模式根据没有必要，我们是程序员，头上并没有标着面向对象开发的程序员。

能够解决问题即好！



