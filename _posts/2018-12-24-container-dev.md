---
layout: post
title: 关于容器技术的思考
date: 2018-12-24
categories: blog
tags: [技术,总结]
description: 对容器的思考

---
把之前讲课的内容放在这儿以待留念



# 讲课内容
![](/img/container-dev/1.JPG)

各位老师，各位同学，大家晚上好。我叫王文超,现在在小米云平台做容器相关的开发工作，很荣幸能和大家分享有关容器和容器编排方面的内容。分享过程中如果大家有任何问题都可以提出来我们一起讨论。

那我们现在就开始吧，首先让我们假设一个场景。有一个工程师，叫做李明。有一天，他准备做一个博客类的网站，博客网站其实是一个典型的web服务工程，大家可以把这个理解为一个普通的web工程。首先，搭网站需要一个服务器，服务器可以是自建的，也可以是从某个公有云租赁的。解决了环境问题，就要看技术选型了。
![](/img/container-dev/2.JPG)
如图，是比较常用的一个软件架构，最前端是一个反向代理服务器，可以是nginx或者apache等等。后面会挂载一台或者多台web服务器，web服务器的相关开发一般我们会使用一些开发语言，例如java、python、go、php等，当需要数据存储时，后端会有数据库和缓冲的使用。我们例子中的李明在权衡后，选择了nginx+java+mysql+redis的解决方案。这也是很多web网站常用的方案。

随着博客系统的成功上线，有很多问题也会接踵而来。例如当访问量增大后，如何很方便的扩容web服务器，需要去重新搭一套环境吗？之前说到，我们部署系统时候，选择了某个语言的某个版本，忽然有一天你发现，这个语言有了新的版本，新版本的某个特性你很想试用一下，但由于和之前版本不兼容，要切换新的版本会付出很大的代价，无奈你只能放弃了这个想法。还有，开始你可能把网站部署在物理机上，现在想切换到某个云平台该怎么办。有时候我们发现，在访问高峰，我们需要多个web服务器，但在访问的低谷时段，我们的服务占用了很多计算资源，是很浪费的，怎么去节省资源？还有最重要的，如何保证服务的稳定。这里的稳定包括很多方面：第一，高可用方面。当某个web服务器出现了不可用状态，如何保证服务的稳定。第二，灰度发布方面。当我们更新系统的配置时，如何保证服务稳定不中断。以上说的这些问题，容器和容器编排都会有对应的解决方案。

李明遇到了以上的问题，然后他听他的朋友说，可以尝试用把应用的传统部署改为容器部署。于是他决定好好研究一下容器。
![](/img/container-dev/3.JPG)
首先地一个问题，什么是容器？看看下面这个docker的图标，是一个大船装了好多集装箱。谈到容器，可以先从集装箱来谈起。 集装箱有什么好处呢？假设一艘运输船要运输很多种类的货物，每个种类的货物形状大小都不一样，而且有的货物是化学药品，和别的货物接触会造成污染， 有些货物是易碎品，有些货物需要特定温度湿度。这个时候集装箱就排上了用场，集装箱把每个货物进行了隔离和保护，同时提供了货物需要的环境。 每个集装箱的外形都很规律，便于运输和存放。 **集装箱为货物提供了环境和隔离，并且把货物进行了标准化** 。容器的思想和集装箱相似，一个容器里面包含了程序及其所依赖的环境，每个容器有统一的启动、停止方式。 从程序角度来看，容器是对程序的一层封装，每个程序可能有千奇百怪的依赖、启动方式，容器就像大一号的进程，把其包含在内。 这样，面向用户的不是各式各样的程序，而是统一的容器提供的操作。 **容器为程序和环境提供了封装，制定了统一标准** 。
![](/img/container-dev/4.JPG)
有时候外行人问我什么是容器的时候，我一般会回答容器是一个轻量级的虚拟机，的确，容器和虚拟机很像，也具有虚拟机的很多特性。比如，容器和虚拟机一样，有镜像，可以打快照。容器运行时候体验和虚拟机差不多，也是有操作系统的概念。 当然容器比虚拟机更加轻量级，这体现在容器镜像所占用的资源更小，容器启动速度更快。当然，相对虚拟机，容器的隔离性也更弱。容器的文件系统和虚拟机也有很大的不同。

为什么容器更加轻量呢？从设计理念来讲，容器和虚拟机都是对计算资源的虚拟和抽象。但虚拟机虚拟的是一台计算机，包括了所有的硬件、和软件。 虚拟机有其对应的内存、cpu、显卡、硬盘等。而容器虚拟的是一个操作系统，不涉及到硬件的东西。因此容器其实是更高级的抽象。我们完全可以在虚拟机中安装容器。例如window版和mac版的docker就是把容器跑在了虚拟机里面。 有时候我们发现容器和虚拟机使用体验差不多，是因为我们使用电脑的主要体验是操作系统之上，如果在一个虚拟机中安装多个操作系统，就可以感觉出和容器的差别来了。

容器和虚拟机的隔离也有差别，虚拟机是完全模拟硬件，两个虚拟机之间是完全隔离的。容器的隔离实现是通过linux的namespace，对主机和域名、信号量、进程编号、网络设备、文件系统、用户做了隔离。而对于内存，cpu等物理资源，只是通过cgroups做了资源的限制。因此，在容器里面执行命令查看cpu、内存等，会看到整个宿主机的cpu、内存参数。

容器和虚拟机的文件系统也有差异，虚拟机使用文件系统和物理机几乎没有什么差异。容器的文件系统是分层存储的，我们最常用的文件系统是AUFS，它分为只读层和可读写层，当删除或修改只读层的文件时候，文件系统通过对文件做标记来表明删除。这样的好处是，一个镜像派生的多个容器可以共用同一个只读层的文件。这样节省了资源，提高启动速度。

正是因为以上的容器的各种特性，导致了容器启动速度快，容量小。也为程序和软件的发布提供一种可能和新的思路： **把代码和环境打包到一起发布** 。所谓容器化正是如此。
![](/img/container-dev/5.JPG)
容器化有什么好处呢？我认为第一点，作为工程师最喜欢的一点，对工程师友好，随时可以尝试新的技术栈。这样你就不用想使用java8的流而不可得，python2和python3的差异也迎刃而解。第二就是容器的启动很轻量，这样在进行扩缩容时候很方便。由于把环境和代码打包在了一起，最后发布线上和开发测试环境是一致的，对于上线部署也是非常便利。还有一个虚拟机或者物理机可以运行多个容器，有利于资源的更充分利用。当然容器化的好处远远不止这些。

![](/img/container-dev/6.JPG)
那我们怎么去学习容器呢？虽然容器引擎有很多，但docker其实是容器的事实标准了。让我们看看学习docker需要大致掌握哪些东西。首先是docker的一些基础概念：image是一个静态的文件，像一个模板一样，我们可以根据image来创建container。Container是实际上跑的为我们提供服务的程序。Repository是一个 image的存储仓库，docker官方提供了一个公共的仓库，也可以自建仓库。我们可以通过仓库来使用别人分享的image。Dockerfile是一个docker提供的自动化构建体系，可以通过dockerfile来自定义自建的image，所以一定要学会用哦。值得说的一点是，使用dockerfile时候，第一行总是以FROM开头，表示基础镜像。基础镜像可以是空白的，也可以是别人做好的镜像你拿来修改下。所以选择合适的基础镜像有时候可以有效减轻工作量。

下面看一些我在使用容器的一些最佳实践：
![](/img/container-dev/7.JPG)

下面是我写的一个dockerfile样例，可以看到，我在dockerfile中用到了我上面说的一些最佳实践。
![](/img/container-dev/8.JPG)

李明了解了一些容器的知识，将博客用docker重新部署。如图所示，用docker部署解决了之前说的很多问题，比如技术栈更换，扩容，迁移，节省资源等。但我们发现使用容器还是有很多问题不能解决，例如博客系统需要特定数量的容器，一旦容器由于某种原因挂掉，稳定性会受到影响。还有使用容器每次扩容倒是方便了，但前面反向代理的配置还是改起来非常麻烦。在更新时候，怎么样做到服务不中断的问题还是难以解决。其实关键问题就是一点：当容器的规模比较大时候，怎么样去管理容器。这正是容器编排干的事情。
![](/img/container-dev/9.JPG)

什么是容器编排呢？下面这句话和这张图我特别喜欢：像管理牲口样管理容器。
![](/img/container-dev/10.JPG)
容器编排，说白了就是去管理容器，把容器分组、分类，让容器协同提供功能。去年的时候，有三大容器编排工具：mesos，swarm，kubernetes并列占据了容器编排的整个市场，到现在基本是kubernetes一家独大了。Kubernetes和docker在容器的地位一样，现在是容器编排的事实标准。

下面让我们看看什么是kubernetes，kubernetes是google开源的一套系统。下面这张是kubernetes的整体架构图。
![](/img/container-dev/11.JPG)
首先，kubernetes是一个分布式系统，分布式系统首先要解决的是状态存储的问题，这里kubernetes使用了etcd来保证数据的一致性，也就是说，kubernetes的所有组件都是无状态性的，也意味着可以随意扩展。etcd使用了raft协议来保持系统的一致性，可以把它理解为一个分布式数据库。kubernetes分为master和node两种角色：master是总指挥，对外提供接口，对内和node通信，node是实际工作的角色。

让我们看看master角色里面的三个组件，apiserver，scheduler，和controller manager。apiserver的作用有两块，第一是提供api，第二与etcd通信。api主要是restapi，包括其中的认证、授权等。与etcd通信这个就比较重要了，因为整个kubernetes集群只有apiserver可以与etcd通信，其它的所有组件都是通过apiserver才能操控数据。这里要特别提到一点，apiserver提供了增删改查和watch的功能，其它的组件的工作都是通过watch保持一个长连接，对它关心的数据做出反应，然后更新状态。这种类似订阅分发的数据通信的方式天生解耦，给扩展提供了很强的便利，如果我们需要做一个扩展，也只需通过apiserver来watch自己关心的数据即可。

然后说说scheduler，scheduler做的事情很简单，一个任务来了，由它决定交给哪个node做。当然中间也会考虑到一些公平性，资源高效利用等等问题。另外我们也可以指定一些调度的特殊规则。

接下来是controller manager，顾名思义，controller manager是整个集群的控制器，它保证了kubernetes里面的功能正常。其实这个组件是由一系列小的组件组成的，每个组件完成自己的工作。

然后看看node里面的两个组件：kubelet和proxy。kubelet可以看做实际干活的人，它的任务就是接受master的指令，然后去管理容器，当然也会定时把当前节点的状态发送给master。proxy组件的主要功能是去操控机器的iptables，修改其中的规则，让容器能够暴露出来，对外提供服务。这里可以看到，kubernetes里面运行的服务，并不依赖kubernetes，整个kubernetes集群挂掉之后，只会影响创建删除修改容器，对已有服务的运行并没有影响，这也是我觉得设计得比较好的一点。

讲完kubernetes的基础架构后，我们来看看kubernetes这些组件协同起来，到底完成了什么工作？说到这里就不得不提到kubernetes里面的资源对象了。Kubernetes把自身所有功能都抽象成了一个个资源，然后在apiserver层提供了所有资源的增删查改功能。这其实是一个非常典型的restful风格设计方式。资源对象其实就是kubernetes里面需要做持久化内容，也就是所谓的状态。这张图我列举了一些主要的资源对象，主要分为四大类：资源对象，配置对象，存储对象，策略对象。这里面node前面说过，后面我们会重点说一下pod，replicaSet ，deployment，service和ingress这几种资源对象。在kubernetes里面，一个资源对象一般是用一个yaml文件或者一个json文件描述的。每个清单的格式相似，开始有一个apiVersion表示版本，kind表示资源种类，metadata表示该资源的元数据，包括名字、标签等等。spec比较关键，每个资源的详细、特殊配置都会在这里面。后续如果运行时，还会有status这个字段。
![](/img/container-dev/12.JPG)

pod是kubernetes的基本调度单位，一个pod是由多个容器组成，在同一个pod中的多个容器可以共享网络和存储。为什么要在容器上面多封装一层呢？我理解把多个容器放到一个pod的场景主要是：当一个容器只会被另外一个容器使用，而且它们俩一荣俱荣，一损俱损。这样从业务上看，这两个容器其实实现了同一个功能。也就是说，pod是业务上的最小逻辑单元。pod这个资源被后续的很多资源使用，但我们不推荐直接创建一个pod，这就和直接创建一个容器没什么区别。发挥不出容器编排的优势。
![](/img/container-dev/13.JPG)
我们可以看看右边的replicaSet。replicaSet这个资源的作用就是，可以自动创建pod并且保持pod的数量。我们可以看到spec里面有replicas和template，template里面的东西其实和pod是一样的。replicaSet通过template创建pod，使其保持在一定的数量上。
![](/img/container-dev/14.JPG)
然后再让我们看看下面几个资源，首先是deployment。Deployment是我们在使用kubernetes时候最常见的使用对象。Deployment实际上在replicaSet上面又包装了一层，当我们创建一个deployment时，会自动创建一个replicaSet来创建启动pod。为什么不直接用replicaSet呢？因为对于一个应用来说，当镜像更新需要滚动升级，replicaSet不能满足需求。Deployment会保持旧的replicaSet同时，再新创建一个replicaSet。逐步调整新旧版本的比例，最后完成升级。所以在kubernetes系统中，deployment对应一个应用。
![](/img/container-dev/15.JPG)
然后让我们看看service。Service其实可以理解为容器的内部负载均衡。Service资源其实对应kube-proxy组件，通过修改iptables，虚拟出一个service ip，访问时候将流量负载转发各个pod中。当然service也可以特殊指定nodeport，通过node的物理端口将pod的服务暴露出去。

那么service是怎么找到它要负载哪些pod的呢？大家也可以看到deployment的创建的pod的metadata里面有labels。service的spec里面有个字段叫做selector。其实这是kubernetes里面很重要的机制。每个资源都可以给自己打任意多个标签，当其他资源需要寻找这个资源的时候，可以根据标签来找。Service通过labels来寻找受自己管理的pod。之前的replicaSet的selector用来标明哪些pod是它创建的。

Ingress 是针对HTTP层的应用来说的，它本质是一个普通的负载均衡应用，通过nodeport开放物理机的80和443端口。它通过监听service所管理的pod，动态去修改自己的反向代理信息。最后为pod提供http层的服务。比如社区版的ingress就是使用nginx实现的。

通过deployment+service+ingress的组合，部署一个普通web应用基本没有问题了。当然还有一些其他类型的资源对象，比如statefulset，daemonSet，cronjob。简单说一下，deployment会创建多个pod，然后通过service负载均衡进行访问。在这里，所有pod作为一个整体出现，单个pod并没有自己的&quot;身份&quot;。statefulset创建的应用又叫做有状态应用，有状态的含义第一在网络上，每个pod都是独立的，第二，每个pod可以附加自己的存储，pod的重启不会导致存储的漂移。Statefulset比较适合主从一些主从结构，或者缓存同步等节点之间需要相互同步的场景。daemonSet确保了每个node上都会有一个pod，一般用来日志、监控或者其他管理应用。Cronjob就是定时任务，可以指定cron表达式。Cronjob里面指定的镜像一定不是长期服务的。而其他资源对象恰恰相反。
![](/img/container-dev/16.JPG)
有了对kubernetes的基本了解，小明可以尝试把他的博客系统部署在kubernetes上了。就和我们刚刚说的一样，使用deployment管理pod，service做负载均衡，ingress把服务暴露到外部。Deployment里面的replicaSet会保证pod的数量，当容器挂了会自动重启，当某个node节点挂了，会自动把这个节点上的容器迁移到其他node上。当pod扩容缩容时候，会ingress会自动更新其负载均衡的配置。当重新发布的时候，只需修改deployment的镜像名称，就可以自动进行滚动升级，完全不会影响服务。至此，小明再也不担心博客出问题了。

将一个博客系统跑在kubernetes中其实是有点像一列火车运输了一根小螺丝。但基于kubernetes搭建一个paas平台是极好的选择。Kubernetes虽然功能、定义都非常丰富，但如果想把kubernetes建成一个生态，还是有很多东西要做。下面我抽一些功能点简单说说实现思路。（有关小米对kubernetes做的扩展略）
![](/img/container-dev/17.JPG)

